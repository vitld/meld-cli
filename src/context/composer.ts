import { readdirSync, readFileSync, existsSync } from "node:fs";
import { join, basename, extname, relative } from "node:path";
import { resolveContextPath } from "../config/types.js";
import type { MeldConfig } from "../config/types.js";
import type { ComposedContext, ContextFile, ProjectIndexEntry, CommandMeta, SkillMeta } from "./types.js";

export function composeContext(hubDir: string, config: MeldConfig): ComposedContext {
  const { inline, contextFiles } = readContext(hubDir, config);
  return {
    hubDir,
    hubPreamble: buildHubPreamble(config),
    projectTable: buildProjectTable(config),
    artifactsSection: buildArtifactsSection(),
    context: inline,
    contextFiles,
    commands: readCommands(hubDir),
    skills: readSkills(hubDir),
  };
}

function buildHubPreamble(config: MeldConfig): string {
  return [
    `# ${config.ide.workspaceName}`,
    "",
    "This is a **meld hub** — a multi-project workspace with shared configuration generated by [meld](https://github.com/ViktorPontinen/meld-cli).",
    "",
    "You are running from a subfolder of the hub (`agents/<name>/`). The hub root is at `../../`.",
    "",
    "## Hub Structure",
    "",
    "| Path | Purpose |",
    "|------|---------|",
    "| `meld.jsonc` | Central config — projects, agents, MCP servers |",
    "| `context/` | Agent instructions — root `.md` files are inlined, subfolders are copied |",
    "| `commands/` | Slash commands available to agents |",
    "| `skills/` | Reusable skills with frontmatter metadata |",
    "| `artifacts/` | Persistent research, plans, and notes |",
    "| `scratch/` | Temporary work (gitignored) |",
    "| `agents/` | Generated output — **do not edit**, regenerated by `meld gen` |",
    "",
    "> To change workspace settings, edit `meld.jsonc` at the hub root and run `meld gen` to regenerate.",
  ].join("\n");
}

function buildProjectTable(config: MeldConfig): string {
  const projects = buildProjectIndex(config);
  if (projects.length === 0) return "";

  const lines: string[] = [
    "## Projects",
    "",
    "| Project | Aliases | Path | Repo |",
    "|---------|---------|------|------|",
  ];

  for (const project of projects) {
    lines.push(
      `| ${project.name} | ${project.aliases.join(", ")} | ${project.path} | ${project.repo ?? ""} |`,
    );
  }

  return lines.join("\n");
}

function buildArtifactsSection(): string {
  return [
    "## Artifacts & Scratch",
    "",
    "- Hub-scoped artifacts: `../../artifacts/hub/`",
    "- Per-project artifacts: `../../artifacts/projects/{project-name}/`",
    "- Scratch (temporary work, gitignored): `../../scratch/`",
    "",
    "> Save research, plans, and notes to the appropriate artifacts folder.",
  ].join("\n");
}

function buildProjectIndex(config: MeldConfig): ProjectIndexEntry[] {
  return Object.entries(config.projects).map(([name, project]) => ({
    name,
    aliases: project.aliases,
    path: project.path,
    ...(project.repo && { repo: project.repo }),
  }));
}

function readContext(hubDir: string, config: MeldConfig): { inline: string; contextFiles: ContextFile[] } {
  const contextPath = resolveContextPath(config.context);
  const dir = join(hubDir, contextPath);

  if (!existsSync(dir)) return { inline: "", contextFiles: [] };

  const entries = readdirSync(dir, { withFileTypes: true });

  // Root .md files → inline
  const mdFiles = entries
    .filter((e) => e.isFile() && e.name.endsWith(".md"))
    .map((e) => e.name)
    .sort();

  const inline = mdFiles.length > 0
    ? mdFiles.map((f) => readFileSync(join(dir, f), "utf-8").trim()).join("\n\n")
    : "";

  // Subdirectories → recursively collect all files
  const contextFiles: ContextFile[] = [];
  const subdirs = entries
    .filter((e) => e.isDirectory())
    .map((e) => e.name)
    .sort();

  for (const subdir of subdirs) {
    collectFiles(join(dir, subdir), dir, contextFiles);
  }

  return { inline, contextFiles };
}

function collectFiles(dirPath: string, relativeTo: string, out: ContextFile[]): void {
  const entries = readdirSync(dirPath, { withFileTypes: true }).sort((a, b) => a.name.localeCompare(b.name));
  for (const entry of entries) {
    const fullPath = join(dirPath, entry.name);
    if (entry.isDirectory()) {
      collectFiles(fullPath, relativeTo, out);
    } else if (entry.isFile()) {
      out.push({
        path: relative(relativeTo, fullPath),
        content: readFileSync(fullPath, "utf-8"),
      });
    }
  }
}

function readCommands(hubDir: string): CommandMeta[] {
  const commandsDir = join(hubDir, "commands");
  if (!existsSync(commandsDir)) return [];

  return readdirSync(commandsDir)
    .filter((f) => f.endsWith(".md"))
    .sort()
    .map((f) => ({
      name: basename(f, extname(f)),
      content: readFileSync(join(commandsDir, f), "utf-8"),
    }));
}

function readSkills(hubDir: string): SkillMeta[] {
  const skillsDir = join(hubDir, "skills");
  if (!existsSync(skillsDir)) return [];

  return readdirSync(skillsDir, { withFileTypes: true })
    .filter((d) => d.isDirectory())
    .sort((a, b) => a.name.localeCompare(b.name))
    .map((d) => {
      const skillFile = join(skillsDir, d.name, "SKILL.md");
      if (!existsSync(skillFile)) return null;

      const raw = readFileSync(skillFile, "utf-8");
      const { frontmatter, body } = parseFrontmatter(raw);

      return { name: d.name, frontmatter, body };
    })
    .filter((s): s is SkillMeta => s !== null);
}

function parseFrontmatter(content: string): { frontmatter: Record<string, unknown>; body: string } {
  const match = content.match(/^---\n([\s\S]*?)\n---\n?([\s\S]*)$/);
  if (!match) {
    return { frontmatter: {}, body: content };
  }

  const yamlStr = match[1];
  const body = match[2].trim();
  const frontmatter = parseSimpleYaml(yamlStr);

  return { frontmatter, body };
}

function parseSimpleYaml(yaml: string): Record<string, unknown> {
  const result: Record<string, unknown> = {};
  const lines = yaml.split("\n");
  let currentKey = "";
  let currentMap: Record<string, string> | null = null;

  for (const line of lines) {
    if (line.trim() === "") continue;

    // Indented line — part of a map value
    const indentedMatch = line.match(/^  (\w[\w-]*): (.+)$/);
    if (indentedMatch && currentKey) {
      if (!currentMap) currentMap = {};
      currentMap[indentedMatch[1]] = indentedMatch[2].trim();
      continue;
    }

    // Flush previous map
    if (currentMap && currentKey) {
      result[currentKey] = currentMap;
      currentMap = null;
    }

    // Top-level key
    const topMatch = line.match(/^(\w[\w-]*): (.+)$/);
    if (topMatch) {
      currentKey = topMatch[1];
      const value = topMatch[2].trim();

      // Array value: [a, b, c]
      if (value.startsWith("[") && value.endsWith("]")) {
        result[currentKey] = value.slice(1, -1).split(",").map((s) => s.trim().replace(/^["']|["']$/g, ""));
      } else if (value === "true") {
        result[currentKey] = true;
      } else if (value === "false") {
        result[currentKey] = false;
      } else {
        result[currentKey] = value.replace(/^["']|["']$/g, "");
      }
      continue;
    }

    // Top-level key with no inline value (map follows)
    const mapKeyMatch = line.match(/^(\w[\w-]*):$/);
    if (mapKeyMatch) {
      currentKey = mapKeyMatch[1];
      currentMap = {};
      continue;
    }
  }

  // Flush final map
  if (currentMap && currentKey) {
    result[currentKey] = currentMap;
  }

  return result;
}
